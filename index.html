<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°œì„ ëœ ë ˆì´ì‹± ê²Œì„ v4 - ê·¹ì ì¸ ì¶”ê²©ì „</title>
    <style>
        /* ê¸°ë³¸ ìŠ¤íƒ€ì¼ ìœ ì§€ */
        body, html { margin: 0; padding: 0; font-family: Arial, sans-serif; height: 100%; background-color: #f0f0f0; }
        #game-container { width: 800px; height: 600px; margin: 20px auto; position: relative; background-color: #5da45d; overflow: hidden; border-radius: 10px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); }

        .car {
            position: absolute;
            width: 50px;
            height: 30px;
            border-radius: 5px 10px 10px 5px; /* ì•ë’¤ ëª¨ì–‘ */
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: white;
            will-change: transform, left, top;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: opacity 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ ì¶”ê°€ */
        }
        .track { position: absolute; width: 600px; height: 400px; border: 25px solid #444; border-radius: 200px; top: 50%; left: 50%; transform: translate(-50%, -50%); box-sizing: border-box; box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4); background-color: #666; }
        .finish-line { position: absolute; width: 70px; height: 10px; background: repeating-linear-gradient(45deg, #fff, #fff 5px, #000 5px, #000 10px); bottom: calc(50% - 200px - 10px / 2 + 25px); left: 50%; transform: translateX(-50%); z-index: 5; box-shadow: 0 0 5px rgba(0,0,0,0.5); border: 1px solid #333; }
        .finish-line::before { content: 'FINISH'; position: absolute; top: -25px; left: 50%; transform: translateX(-50%); color: white; font-weight: bold; font-size: 14px; text-shadow: 1px 1px 2px black; z-index: 6; }
        .track::after { content: ''; position: absolute; width: calc(100% - 50px); height: calc(100% - 50px); top: 25px; left: 25px; border-radius: 175px; border: 2px dashed rgba(255, 255, 255, 0.5); pointer-events: none; box-sizing: border-box; }
        .controls { text-align: center; margin-top: 10px; padding: 10px; background-color: #333; color: white; border-radius: 5px; }
        button { padding: 10px 20px; font-size: 16px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px; transition: background-color 0.2s; }
        button:hover { background-color: #45a049; }
        button:disabled { background-color: #aaa; cursor: not-allowed; }
        input { width: 50px; padding: 8px; border-radius: 5px; border: 1px solid #ccc; margin: 0 10px; text-align: center; }
        .result { text-align: center; font-size: 24px; margin-top: 20px; font-weight: bold; color: #333; min-height: 60px; }
        .race-info { text-align: center; padding: 8px 15px; font-size: 16px; background-color: rgba(0, 0, 0, 0.6); color: white; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); border-radius: 5px; width: auto; min-width: 200px; white-space: nowrap; z-index: 10; }
        .lap-counter { position: absolute; top: 15px; right: 15px; background-color: rgba(0, 0, 0, 0.6); color: white; padding: 5px 10px; border-radius: 5px; font-size: 16px; font-weight: bold; z-index: 10; }

        /* === ì‹œê° íš¨ê³¼ ê°•í™” === */
        .car.boost {
            box-shadow: 0 0 15px 5px yellow, inset 0 0 5px rgba(255, 255, 100, 0.5); /* ë” ê°•ë ¬í•œ ë¶€ìŠ¤íŠ¸ íš¨ê³¼ */
            animation: boostPulse 0.5s infinite alternate; /* ë¶€ìŠ¤íŠ¸ ì‹œ ê¹œë¹¡ì„ */
        }
        .car.slowdown {
            opacity: 0.6; /* ë” ëˆˆì— ë„ëŠ” ê°ì† íš¨ê³¼ */
            box-shadow: 0 0 10px 3px rgba(255, 0, 0, 0.7); /* ê°ì† ì‹œ ë¶‰ì€ ê·¸ë¦¼ì */
            /* animation: slowdownWobble 0.3s infinite; */ /* ê°ì† ì‹œ ì•½ê°„ì˜ ë–¨ë¦¼ (ì„ íƒ ì‚¬í•­) */
        }
        .car.leader-penalty {
            /* ì„ ë‘ ì£¼ì í˜ë„í‹° ì‹œ ë¯¸ë¬˜í•œ ì‹œê°ì  í‘œì‹œ (ì„ íƒ ì‚¬í•­) */
            /* ì˜ˆ: box-shadow: inset 0 0 5px rgba(200, 0, 0, 0.5); */
        }
        .car.catchup-boost {
            /* ì¶”ê²© ë¶€ìŠ¤íŠ¸ ì‹œ ë¯¸ë¬˜í•œ ì‹œê°ì  í‘œì‹œ (ì„ íƒ ì‚¬í•­) */
            /* ì˜ˆ: box-shadow: inset 0 0 5px rgba(0, 200, 0, 0.5); */
        }

        @keyframes boostPulse {
            from { box-shadow: 0 0 15px 5px yellow, inset 0 0 5px rgba(255, 255, 100, 0.5); }
            to   { box-shadow: 0 0 25px 8px gold, inset 0 0 8px rgba(255, 255, 150, 0.7); }
        }
        /* @keyframes slowdownWobble {
            0% { transform: translateX(-1px); }
            50% { transform: translateX(1px); }
            100% { transform: translateX(-1px); }
        } */
        /* ìš°ìŠ¹ì ì• ë‹ˆë©”ì´ì…˜ì€ endGame í•¨ìˆ˜ì—ì„œ ë™ì ìœ¼ë¡œ ìƒì„± */

    </style>
</head>
<body>
<div id="game-container">
    <div class="track">
        <div class="finish-line"></div>
    </div>
    <div id="lap-counter" class="lap-counter">Lap: 0 / 3</div>
    <div class="race-info" id="race-info">ì¤€ë¹„...</div>
</div>

<div class="controls">
    <label for="player-count">ì°¸ê°€ì ìˆ˜:</label>
    <input type="number" id="player-count" min="2" max="8" value="4">
    <button id="start-button">ê²Œì„ ì‹œì‘</button>
</div>

<div class="result" id="result"></div>

<script>
    // ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° (ë™ì¼)
    const gameContainer = document.getElementById('game-container');
    const track = document.querySelector('.track');
    const startButton = document.getElementById('start-button');
    const playerCountInput = document.getElementById('player-count');
    const resultDiv = document.getElementById('result');
    const raceInfoDiv = document.getElementById('race-info');
    const lapCounterElement = document.getElementById('lap-counter');

    // ê²Œì„ ì„¤ì • (ë™ì¼)
    const LAPS_TO_WIN = 3;

    // ê²Œì„ ìƒíƒœ (ë™ì¼)
    let cars = [];
    let gameStarted = false;
    let gameFinished = false;
    let finishedCars = [];
    let animationFrameId = null;
    let lastTimestamp = 0;
    let pathLength = 0; // ê²½ë¡œ ê¸¸ì´ ì €ì¥ ë³€ìˆ˜ ì¶”ê°€

    // ì°¨ëŸ‰ ì •ë³´ (ë™ì¼)
    const carDetails = [
        { color: "#FF0000", name: "Red Fury" }, { color: "#0000FF", name: "Blue Bolt" },
        { color: "#00FF00", name: "Green Ghost" }, { color: "#FFFF00", name: "Yellow Flash" },
        { color: "#FF00FF", name: "Magenta Max" }, { color: "#00FFFF", name: "Cyan Comet" },
        { color: "#FFA500", name: "Orange Rocket" }, { color: "#800080", name: "Purple Phantom" }
    ];

    // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ --- (ë™ì¼)
    startButton.addEventListener('click', startGame);
    document.addEventListener('DOMContentLoaded', () => {
        lapCounterElement.textContent = `Lap: 0 / ${LAPS_TO_WIN}`;
        // ì´ˆê¸° ê²½ë¡œ ê³„ì‚° (pathLength ì—…ë°ì´íŠ¸ ìœ„í•¨)
        const initialPath = getPath();
        if(initialPath) pathLength = calculatePathLength(initialPath);
        animationFrameId = requestAnimationFrame(updateGame); // ì´ˆê¸° í”„ë ˆì„ ì‹œì‘
    });

    // --- ê²Œì„ ë¡œì§ í•¨ìˆ˜ ---

    function startGame() { // ê²½ë¡œ ê¸¸ì´ ê³„ì‚° ì¶”ê°€
        if (gameStarted) return;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        clearCars();
        gameStarted = true;
        gameFinished = false;
        finishedCars = [];
        resultDiv.textContent = '';
        raceInfoDiv.textContent = 'ë ˆì´ìŠ¤ ì‹œì‘!';
        lapCounterElement.textContent = `Lap: 1 / ${LAPS_TO_WIN}`;
        startButton.disabled = true;
        playerCountInput.disabled = true;

        // ê²½ë¡œ ë° ê¸¸ì´ ê³„ì‚°
        const path = getPath();
        if (!path) {
            console.error("Failed to get track path.");
            // ê²Œì„ ì‹œì‘ ì‹¤íŒ¨ ì²˜ë¦¬ (ì˜ˆ: ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼)
            gameStarted = false;
            startButton.disabled = false;
            playerCountInput.disabled = false;
            raceInfoDiv.textContent = 'ì˜¤ë¥˜: íŠ¸ë™ ê²½ë¡œë¥¼ ê³„ì‚°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
            return;
        }
        pathLength = calculatePathLength(path); // ê²½ë¡œ ê¸¸ì´ ì—…ë°ì´íŠ¸

        const playerCount = parseInt(playerCountInput.value) || 4;
        createCars(Math.min(Math.max(playerCount, 2), 8), path); // ê²½ë¡œ ì „ë‹¬
        lastTimestamp = performance.now();
        animationFrameId = requestAnimationFrame(updateGame);
    }

    function clearCars() { // ë™ì¼
        cars.forEach(car => {
            if (car.element && car.element.parentNode) {
                car.element.parentNode.removeChild(car.element);
            }
            if (car.debugLine) gameContainer.removeChild(car.debugLine); // ë””ë²„ê·¸ ë¼ì¸ ì œê±°
        });
        cars = [];
        cachedPath = null; // ê²½ë¡œ ìºì‹œ ì´ˆê¸°í™”
        pathLength = 0; // ê²½ë¡œ ê¸¸ì´ ì´ˆê¸°í™”
    }

    function isLightColor(color) { // ë™ì¼
        const hex = color.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 128;
    }

    function createCars(count, path) { // path ì¸ì ë°›ë„ë¡ ìˆ˜ì •
        // const path = getPath(); // startGameì—ì„œ ë¯¸ë¦¬ ê³„ì‚°ëœ ê²½ë¡œ ì‚¬ìš©
        if (!path || path.length < 2) {
            console.error("Cannot create cars without a valid path.");
            return;
        }
        const startPoint = path[0];

        for (let i = 0; i < count; i++) {
            const detail = carDetails[i % carDetails.length];
            const carColor = detail.color;
            const isLight = isLightColor(carColor);

            const carElement = document.createElement('div');
            carElement.className = 'car';
            carElement.textContent = (i + 1);
            carElement.style.backgroundColor = carColor;
            carElement.title = detail.name;
            if (isLight) carElement.style.color = 'black';

            applyCarDetails(carElement, carColor);
            gameContainer.appendChild(carElement);

            // ì‹œì‘ ìœ„ì¹˜ ë¶„ì‚° ë¡œì§ (ë™ì¼)
            const angleOffset = (i - (count - 1) / 2) * 0.15;
            const startAngle = Math.atan2(path[1].y - startPoint.y, path[1].x - startPoint.x);
            const finalAngle = startAngle + angleOffset;
            const offsetRadius = 20;
            const initialX = startPoint.x + Math.cos(finalAngle) * offsetRadius;
            const initialY = startPoint.y + Math.sin(finalAngle) * offsetRadius;

            // *** ê¸°ë³¸ ì„±ëŠ¥ ê²©ì°¨ ë” í™•ëŒ€ ***
            const baseMaxSpeed = 3.0 + Math.random() * 4.0; // ë²”ìœ„ ì¦ê°€ (3.0 ~ 7.0) -> ë” í° ì†ë„ì°¨
            const acceleration = 0.04 + Math.random() * 0.09; // ë²”ìœ„ ì¦ê°€ (0.04 ~ 0.13) -> ë” í° ê°€ì†ë„ì°¨

            const car = {
                element: carElement, number: i + 1, name: detail.name,
                x: initialX, y: initialY,
                speed: 0,
                baseMaxSpeed: baseMaxSpeed,
                effectiveMaxSpeed: baseMaxSpeed,
                acceleration: acceleration,
                speedModifierDuration: 0,
                speedModifierAmount: 0,
                finished: false, lap: 0, pathIndex: 0, pathProgress: 0,
                color: carColor,
                position: { x: initialX, y: initialY },
                targetPosition: { x: initialX, y: initialY },
                isLeading: false, // ì„ ë‘ ì—¬ë¶€ í”Œë˜ê·¸
                distanceBehindLeader: 0 // ì„ ë‘ì™€ì˜ ê±°ë¦¬ (ê³„ì‚°ìš©)
                // debugLine: createDebugLine(carColor) // ë””ë²„ê¹…ìš© ì„  (í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
            };

            // ì´ˆê¸° ìœ„ì¹˜/ë°©í–¥ ì„¤ì • (ë™ì¼)
            car.element.style.left = car.x + 'px';
            car.element.style.top = car.y + 'px';
            const dx = path[1].x - path[0].x;
            const dy = path[1].y - path[0].y;
            const initialAngleRad = Math.atan2(dy, dx);
            car.element.style.transform = `rotate(${initialAngleRad}rad)`;

            cars.push(car);
        }
    }

    // ë””ë²„ê¹…ìš© ì„  ìƒì„± í•¨ìˆ˜ (ì˜µì…˜)
    // function createDebugLine(color) {
    //     const line = document.createElement('div');
    //     line.style.position = 'absolute';
    //     line.style.width = '2px';
    //     line.style.height = '2px'; // ì ìœ¼ë¡œ ì‹œì‘
    //     line.style.backgroundColor = color;
    //     line.style.opacity = '0.7';
    //     line.style.zIndex = '1';
    //     line.style.transformOrigin = '0 0';
    //     gameContainer.appendChild(line);
    //     return line;
    // }

    function applyCarDetails(element, color) { // ë™ì¼ (í—¤ë“œ/í…Œì¼ ë¼ì´íŠ¸ ìœ„ì¹˜ ì¡°ì •ë¨)
        element.style.textShadow = isLightColor(color) ? '1px 1px 1px rgba(0,0,0,0.5)' : '1px 1px 1px rgba(255,255,255,0.5)';
        const lightElement = document.createElement('div');
        lightElement.style.position = 'absolute'; lightElement.style.width = '4px'; lightElement.style.height = '4px';
        lightElement.style.background = '#fff'; lightElement.style.borderRadius = '50%'; lightElement.style.boxShadow = '0 0 4px white';
        lightElement.style.top = '6px'; lightElement.style.left = '5px'; // ì•ìª½ (ì™¼ìª½)
        element.appendChild(lightElement);
        const tailLight1 = document.createElement('div');
        tailLight1.style.position = 'absolute'; tailLight1.style.width = '6px'; tailLight1.style.height = '3px';
        tailLight1.style.background = 'red'; tailLight1.style.borderRadius = '1px';
        tailLight1.style.bottom = '5px'; tailLight1.style.right = '5px'; // ë’¤ìª½ (ì˜¤ë¥¸ìª½)
        element.appendChild(tailLight1);
        const tailLight2 = tailLight1.cloneNode(); tailLight2.style.right = '15px'; element.appendChild(tailLight2);
    }


    // íŠ¸ë™ ê²½ë¡œ ìºì‹± (ë™ì¼)
    let cachedPath = null;
    let lastTrackWidth = 0;
    let lastTrackHeight = 0;

    function getPath() { // ë™ì¼
        const trackRect = track.getBoundingClientRect();
        const gameRect = gameContainer.getBoundingClientRect();
        // Check if container/track dimensions are valid
        if (!trackRect || trackRect.width <= 0 || trackRect.height <= 0 || !gameRect) {
            // console.warn("Track or game container dimensions are invalid during getPath.");
            return cachedPath; // Return cached path if available, otherwise null
        }
        if (cachedPath && trackRect.width === lastTrackWidth && trackRect.height === lastTrackHeight) return cachedPath;

        const trackLeft = trackRect.left - gameRect.left;
        const trackTop = trackRect.top - gameRect.top;
        const trackWidth = trackRect.width;
        const trackHeight = trackRect.height;
        const points = [];
        const segments = 120; // ê²½ë¡œ ì •ë°€ë„
        const centerX = trackLeft + trackWidth / 2;
        const centerY = trackTop + trackHeight / 2;
        const trackBorderWidth = parseFloat(getComputedStyle(track).borderWidth);
        if (isNaN(trackBorderWidth)) {
            console.error("Failed to parse track border width.");
            return null; // Return null if border width is invalid
        }
        const innerPadding = 15; // íŠ¸ë™ ì•ˆìª½ ì—¬ë°±
        const radiusX = (trackWidth / 2) - trackBorderWidth - innerPadding;
        const radiusY = (trackHeight / 2) - trackBorderWidth - innerPadding;

        // Ensure radii are positive
        if (radiusX <= 0 || radiusY <= 0) {
            console.warn("Calculated track radii are non-positive. Check track dimensions and border.", {trackWidth, trackHeight, trackBorderWidth, innerPadding});
            return null; // Return null if radii are invalid
        }

        const startAngle = Math.PI / 2; // 12ì‹œ ë°©í–¥ ìœ„ìª½ ì‹œì‘
        for (let i = 0; i <= segments; i++) { // segments + 1 points to close the loop
            const angle = startAngle + (Math.PI * 2 * i) / segments; // ì‹œê³„ ë°©í–¥
            const x = centerX + Math.cos(angle) * radiusX;
            const y = centerY + Math.sin(angle) * radiusY;
            points.push({ x, y });
        }
        lastTrackWidth = trackRect.width; lastTrackHeight = trackRect.height;
        cachedPath = points;
        // console.log("New path calculated. Length:", points.length); // ê²½ë¡œ ê³„ì‚° ë¡œê·¸
        return points;
    }

    // ê²½ë¡œ ì´ ê¸¸ì´ ê³„ì‚° í•¨ìˆ˜
    function calculatePathLength(path) {
        let totalLength = 0;
        if (!path || path.length < 2) return 0;
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i + 1];
            totalLength += Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        // console.log("Calculated Path Length:", totalLength); // ê²½ë¡œ ê¸¸ì´ ë¡œê·¸
        return totalLength;
    }

    // ì„ ë‘ ì°¨ëŸ‰ê³¼ì˜ ê±°ë¦¬ ê³„ì‚° (ë© + ê²½ë¡œ ì§„í–‰ë¥  ê¸°ì¤€)
    function calculateDistanceBehind(leader, follower, totalPathSegments, segmentLengths) {
        if (!leader || !follower || leader === follower || totalPathSegments <= 0 || !segmentLengths || segmentLengths.length !== totalPathSegments) return 0;

        // ê° ì°¨ëŸ‰ì˜ ì´ ì§„í–‰ ê±°ë¦¬ ê³„ì‚° (ë© * ì´ ê²½ë¡œ ê¸¸ì´ + í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ê¹Œì§€ì˜ ê±°ë¦¬ + í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ ë‚´ ì§„í–‰ ê±°ë¦¬)
        let leaderProgressDistance = 0;
        for(let i = 0; i < leader.pathIndex; i++) {
            leaderProgressDistance += segmentLengths[i];
        }
        leaderProgressDistance += leader.pathProgress;
        const leaderTotalDistance = leader.lap * pathLength + leaderProgressDistance;

        let followerProgressDistance = 0;
        for(let i = 0; i < follower.pathIndex; i++) {
            followerProgressDistance += segmentLengths[i];
        }
        followerProgressDistance += follower.pathProgress;
        const followerTotalDistance = follower.lap * pathLength + followerProgressDistance;

        // ê±°ë¦¬ ì°¨ì´ ê³„ì‚° (í•­ìƒ ì–‘ìˆ˜)
        const distanceDiff = Math.max(0, leaderTotalDistance - followerTotalDistance);

        return distanceDiff;
    }

    // ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´ ë¯¸ë¦¬ ê³„ì‚° (ì„±ëŠ¥ ìµœì í™”)
    let segmentLengthsCache = null;
    function getSegmentLengths(path) {
        if (!path || path.length < 2) return null;
        if (segmentLengthsCache && segmentLengthsCache.length === path.length - 1) {
            return segmentLengthsCache;
        }
        const lengths = [];
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i + 1];
            lengths.push(Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)));
        }
        segmentLengthsCache = lengths;
        return lengths;
    }


    function updateGame(timestamp) {
        if (!gameStarted || gameFinished) {
            // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì¢…ë£Œëœ ê²½ìš°ì—ë„ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ìœ ì§€ (DOMContentLoadedì—ì„œ ì‹œì‘í•˜ë¯€ë¡œ)
            // ë‹¨, ì—…ë°ì´íŠ¸ ë¡œì§ì€ ì‹¤í–‰í•˜ì§€ ì•ŠìŒ.
            animationFrameId = requestAnimationFrame(updateGame);
            return;
        }

        const deltaTime = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;
        const clampedDelta = Math.min(deltaTime, 0.1); // ìµœëŒ€ í”„ë ˆì„ ê°„ê²© ì œí•œ (ë™ ë°©ì§€)

        const path = getPath();
        if (!path || path.length < 2) {
            console.error("Update failed: Invalid path.");
            animationFrameId = requestAnimationFrame(updateGame); // ë£¨í”„ëŠ” ê³„ì†
            return; // ê²½ë¡œ ì—†ìœ¼ë©´ ì—…ë°ì´íŠ¸ ì¤‘ë‹¨
        }
        const totalPathSegments = path.length -1; // ì‹¤ì œ ì´ë™ ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜
        const segmentLengths = getSegmentLengths(path); // ì„¸ê·¸ë¨¼íŠ¸ ê¸¸ì´ ê°€ì ¸ì˜¤ê¸°
        if (!segmentLengths) {
            console.error("Update failed: Invalid segment lengths.");
            animationFrameId = requestAnimationFrame(updateGame);
            return;
        }


        // 1. ì„ ë‘ ì°¨ëŸ‰ ì°¾ê¸° ë° ê±°ë¦¬ ê³„ì‚°
        let leadingCar = null;
        let maxTotalDistance = -1;

        cars.forEach(car => {
            car.isLeading = false; // ì´ˆê¸°í™”
            if (car.finished) return;

            let currentProgressDistance = 0;
            for(let i = 0; i < car.pathIndex; i++) {
                currentProgressDistance += segmentLengths[i];
            }
            currentProgressDistance += car.pathProgress;
            const currentTotalDistance = car.lap * pathLength + currentProgressDistance;

            if (currentTotalDistance > maxTotalDistance) {
                maxTotalDistance = currentTotalDistance;
                leadingCar = car;
            }
        });

        // ì„ ë‘ ì°¨ëŸ‰ ì„¤ì • ë° ê±°ë¦¬ ê³„ì‚°
        if(leadingCar) leadingCar.isLeading = true;
        cars.forEach(car => {
            if (!car.finished && leadingCar) {
                car.distanceBehindLeader = calculateDistanceBehind(leadingCar, car, totalPathSegments, segmentLengths);
            } else {
                car.distanceBehindLeader = 0;
            }
        });


        // 2. ê° ì°¨ëŸ‰ ì—…ë°ì´íŠ¸
        cars.forEach(car => {
            if (car.finished) return;

            car.element.classList.remove('boost', 'slowdown', 'leader-penalty', 'catchup-boost'); // ìƒíƒœ í´ë˜ìŠ¤ ì´ˆê¸°í™”

            // --- ì†ë„ ë³€ë™ ë¡œì§ (Catch-up ë° Leader Penalty ê°•í™”) ---
            car.speedModifierDuration = Math.max(0, car.speedModifierDuration - clampedDelta);

            if (car.speedModifierDuration <= 0) {
                car.speedModifierAmount = 0; // íš¨ê³¼ ì´ˆê¸°í™”

                // *** ì´ë²¤íŠ¸ ë°œìƒ í™•ë¥  ë° ì¢…ë¥˜ ì¡°ì • (ì„ ë‘/í›„ë¯¸ ë”°ë¼ ì°¨ë“±) ***
                let eventChance = 0.018; // ê¸°ë³¸ ì´ë²¤íŠ¸ ë°œìƒ í™•ë¥  (ì•½ê°„ ì¦ê°€)
                let boostProbability = 0.5; // ê¸°ë³¸ ë¶€ìŠ¤íŠ¸ í™•ë¥  (50%)

                const MAX_CATCHUP_DISTANCE = pathLength * 0.6; // ì¶”ê²© ë¶€ìŠ¤íŠ¸ê°€ ê°•í•´ì§€ëŠ” ìµœëŒ€ ê±°ë¦¬ (íŠ¸ë™ ì ˆë°˜ ì´ìƒ)
                const LEADER_PENALTY_THRESHOLD = pathLength * 0.1; // ì„ ë‘ê°€ ì•½ê°„ì˜ ê±°ë¦¬ì°¨ë¥¼ ë²Œë ¸ì„ ë•Œ í˜ë„í‹° í™•ë¥  ì¦ê°€ ì‹œì‘

                if (car.isLeading && cars.length > 1) {
                    // ì„ ë‘ ì£¼ì: ì´ë²¤íŠ¸ ë°œìƒ í™•ë¥  ì¦ê°€, ê°ì† í™•ë¥  ì¦ê°€
                    eventChance *= 1.4; // ì´ë²¤íŠ¸ ë°œìƒ í™•ë¥  40% ì¦ê°€
                    boostProbability = 0.35; // ë¶€ìŠ¤íŠ¸ ë‚˜ì˜¬ í™•ë¥  35% (ì¦‰, ê°ì† ë‚˜ì˜¬ í™•ë¥  65%)
                    // ì„ ë‘ì§€ë§Œ ë°”ë¡œ ë’¤ì— ë‹¤ë¥¸ ì°¨ê°€ ë¶™ì–´ìˆìœ¼ë©´ í˜ë„í‹° ì™„í™” (ì„ íƒì )
                    const closestFollowerDist = cars.reduce((minDist, otherCar) => {
                        if (!otherCar.finished && otherCar !== car) {
                            return Math.min(minDist, otherCar.distanceBehindLeader);
                        }
                        return minDist;
                    }, Infinity);
                    if (closestFollowerDist < LEADER_PENALTY_THRESHOLD * 0.2) { // ë§¤ìš° ê·¼ì ‘í•  ê²½ìš°
                        eventChance *= 0.8; // í˜ë„í‹° í™•ë¥  ë‹¤ì‹œ ì•½ê°„ ê°ì†Œ
                        boostProbability = 0.45;
                    }
                    car.element.classList.add('leader-penalty'); // ì‹œê°ì  í‘œì‹œ (CSS ì •ì˜ í•„ìš”)

                } else if (car.distanceBehindLeader > 0) {
                    // í›„ë¯¸ ì£¼ì: ê±°ë¦¬ì— ë”°ë¼ ì´ë²¤íŠ¸ í™•ë¥  ë° ë¶€ìŠ¤íŠ¸ í™•ë¥  ì¦ê°€
                    const distanceFactor = Math.min(car.distanceBehindLeader / MAX_CATCHUP_DISTANCE, 1.0); // 0.0 ~ 1.0
                    eventChance *= (1 + 0.3 * distanceFactor); // ìµœëŒ€ 30% í™•ë¥  ì¦ê°€
                    boostProbability = 0.5 + (0.30 * distanceFactor); // ìµœëŒ€ 80%ê¹Œì§€ ë¶€ìŠ¤íŠ¸ í™•ë¥  ì¦ê°€
                    car.element.classList.add('catchup-boost'); // ì‹œê°ì  í‘œì‹œ (CSS ì •ì˜ í•„ìš”)
                }

                // ì´ë²¤íŠ¸ ë°œìƒ ê²°ì •
                if (Math.random() < eventChance) {
                    const isBoost = Math.random() < boostProbability;
                    if (isBoost) {
                        // ë¶€ìŠ¤íŠ¸: ê°•ë„ ë° ì§€ì†ì‹œê°„ ì¦ê°€
                        car.speedModifierAmount = car.baseMaxSpeed * (0.30 + Math.random() * 0.45); // 30% ~ 75% ë¶€ìŠ¤íŠ¸ (ë” ê°•ë ¥í•˜ê²Œ)
                        car.speedModifierDuration = 1.2 + Math.random() * 1.8; // ì§€ì†ì‹œê°„ ì•½ê°„ ì¦ê°€
                    } else {
                        // ê°ì†: ê°•ë„ ë° ì§€ì†ì‹œê°„ ì¦ê°€ (ì„ ë‘ì—ê²Œ ë” ì¹˜ëª…ì )
                        car.speedModifierAmount = -car.baseMaxSpeed * (0.25 + Math.random() * 0.40); // 25% ~ 65% ê°ì† (ë” ê°•ë ¥í•˜ê²Œ)
                        car.speedModifierDuration = 1.0 + Math.random() * 1.5; // ì§€ì†ì‹œê°„ ì•½ê°„ ì¦ê°€
                    }
                }
            }

            // í˜„ì¬ íš¨ê³¼ ì ìš© ë° ì‹œê° íš¨ê³¼
            if (car.speedModifierAmount > 0) car.element.classList.add('boost');
            else if (car.speedModifierAmount < 0) car.element.classList.add('slowdown');

            // ìœ íš¨ ìµœê³  ì†ë„ ê³„ì‚° (ìµœì†Œ ì†ë„ ë³´ì¥)
            car.effectiveMaxSpeed = Math.max(car.baseMaxSpeed * 0.4, car.baseMaxSpeed + car.speedModifierAmount);

            // --- ê°€ì† ë° ì†ë„ ì—…ë°ì´íŠ¸ ---
            // ì„ ë‘ ì¶”ê²© ê°€ì† ë³´ë„ˆìŠ¤ (ì„ íƒì , ìœ„ ì´ë²¤íŠ¸ ì¡°ì •ê³¼ ì¤‘ë³µë  ìˆ˜ ìˆìŒ)
            // let accelBonus = 0;
            // if (!car.isLeading && car.distanceBehindLeader > pathLength * 0.1) {
            //     accelBonus = car.acceleration * (Math.min(car.distanceBehindLeader / (pathLength * 0.5), 1.0) * 0.2); // ìµœëŒ€ 20% ê°€ì† ë³´ë„ˆìŠ¤
            // }
            // car.speed = Math.min(car.speed + (car.acceleration + accelBonus) * clampedDelta, car.effectiveMaxSpeed);

            // ê¸°ë³¸ ê°€ì†/ê°ì†
            if (car.speed < car.effectiveMaxSpeed) {
                car.speed += car.acceleration * clampedDelta * (1.0 + (car.speedModifierAmount > 0 ? 0.1 : 0)); // ë¶€ìŠ¤íŠ¸ì‹œ ê°€ì† ì•½ê°„ ë” ë¹ ë¥´ê²Œ
            } else if (car.speed > car.effectiveMaxSpeed) {
                // ìì—° ê°ì† ë˜ëŠ” ë¸Œë ˆì´í‚¹ (effectiveMaxSpeedê°€ ë‚®ì•„ì¡Œì„ ë•Œ)
                car.speed = Math.max(car.effectiveMaxSpeed, car.speed - car.acceleration * clampedDelta * 2.5); // ê°ì†ì€ ë” ë¹ ë¥´ê²Œ
            }
            car.speed = Math.max(0, car.speed); // ì†ë„ëŠ” 0 ì´ìƒ


            // --- ê²½ë¡œ ì´ë™ ë¡œì§ (ì´ì „ê³¼ ë™ì¼, segmentLengths ì‚¬ìš©) ---
            let distanceToMove = car.speed * clampedDelta * 50; // ì´ë™ ê±°ë¦¬ ìŠ¤ì¼€ì¼ ì¡°ì • ê°€ëŠ¥

            while (distanceToMove > 0 && !car.finished && car.pathIndex < totalPathSegments) {
                const currentSegmentLength = segmentLengths[car.pathIndex];
                if (currentSegmentLength <= 0) { // ê¸¸ì´ 0 ì„¸ê·¸ë¨¼íŠ¸ ê±´ë„ˆë›°ê¸°
                    car.pathIndex++;
                    car.pathProgress = 0;
                    if (car.pathIndex >= totalPathSegments) { // ê²½ë¡œ ë ë„ë‹¬
                        car.pathIndex = 0; // ë‹¤ìŒ ë© ì‹œì‘ ì¸ë±ìŠ¤
                        handleLapCompletion(car);
                        if (car.finished) break;
                    }
                    continue;
                }

                const remainingDistanceInSegment = currentSegmentLength - car.pathProgress;

                if (distanceToMove >= remainingDistanceInSegment) {
                    distanceToMove -= remainingDistanceInSegment;
                    car.pathProgress = 0; // ë‹¤ìŒ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘
                    car.pathIndex++;
                    if (car.pathIndex >= totalPathSegments) { // ê²½ë¡œ ë ë„ë‹¬
                        car.pathIndex = 0; // ë‹¤ìŒ ë© ì‹œì‘ ì¸ë±ìŠ¤
                        handleLapCompletion(car);
                        if (car.finished) break; // ì™„ì£¼í–ˆìœ¼ë©´ ë£¨í”„ íƒˆì¶œ
                    }
                } else {
                    car.pathProgress += distanceToMove;
                    distanceToMove = 0; // ì´ë²ˆ í”„ë ˆì„ ì´ë™ ì™„ë£Œ
                }
            }

            // --- ìœ„ì¹˜ ë° íšŒì „ ì—…ë°ì´íŠ¸ (ì´ì „ê³¼ ê±°ì˜ ë™ì¼) ---
            if (car.pathIndex >= totalPathSegments) car.pathIndex = totalPathSegments -1; // ë°°ì—´ ë²”ìœ„ ì´ˆê³¼ ë°©ì§€

            const finalCurrentPoint = path[car.pathIndex];
            const finalNextPoint = path[car.pathIndex + 1]; // ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ ì²˜ë¦¬ ì£¼ì˜ (points ë°°ì—´ì€ segments+1ê°œ)


            const finalDx = finalNextPoint.x - finalCurrentPoint.x;
            const finalDy = finalNextPoint.y - finalCurrentPoint.y;
            const finalSegmentLength = segmentLengths[car.pathIndex]; // ë¯¸ë¦¬ ê³„ì‚°ëœ ê°’ ì‚¬ìš©

            // ë³´ê°„ ê³„ìˆ˜ t ê³„ì‚° (0ì´ë©´ í˜„ì¬ ì , 1ì´ë©´ ë‹¤ìŒ ì )
            let t = (finalSegmentLength > 0) ? car.pathProgress / finalSegmentLength : 0;
            t = Math.max(0, Math.min(1, t)); // t ê°’ì„ 0ê³¼ 1 ì‚¬ì´ë¡œ ì œí•œ

            // ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            car.targetPosition.x = finalCurrentPoint.x + finalDx * t;
            car.targetPosition.y = finalCurrentPoint.y + finalDy * t;

            // ë¶€ë“œëŸ¬ìš´ ì´ë™ (LERP)
            const lerpFactor = 0.9; // ê°’ì„ ë†’ì´ë©´ ë” ë¹ ë¥´ê²Œ ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™ (ë°˜ì‘ì„± ì¦ê°€)
            car.x = car.x + (car.targetPosition.x - car.x) * lerpFactor;
            car.y = car.y + (car.targetPosition.y - car.y) * lerpFactor;

            // íšŒì „ ë° ì‹œê° íš¨ê³¼ ì ìš©
            const angleRad = Math.atan2(finalDy, finalDx);
            // ì½”ë„ˆë§ ê¸°ìš¸ê¸° (tilt) íš¨ê³¼ëŠ” ìœ ì§€í•˜ê±°ë‚˜ ì¡°ì ˆ ê°€ëŠ¥
            let tilt = 0; const pathRatio = car.pathIndex / totalPathSegments;
            if (pathRatio > 0.05 && pathRatio < 0.20) tilt = 0.1; else if (pathRatio > 0.30 && pathRatio < 0.45) tilt = -0.1;
            else if (pathRatio > 0.55 && pathRatio < 0.70) tilt = 0.1; else if (pathRatio > 0.80 && pathRatio < 0.95) tilt = -0.1;

            // ì†ë„ì— ë”°ë¥¸ í”ë“¤ë¦¼ íš¨ê³¼ (wobble)
            const wobbleAmplitude = 0.7; // í”ë“¤ë¦¼ ê°•ë„ ì¦ê°€
            const effectiveSpeedRatio = car.effectiveMaxSpeed > 0 ? car.speed / car.effectiveMaxSpeed : 0;
            const wobble = Math.sin(timestamp / 80 + car.number * 2) * effectiveSpeedRatio * wobbleAmplitude; // ì†ë„ ë¹„ë¡€, ì°¨ë§ˆë‹¤ ë‹¤ë¥´ê²Œ

            // slowdown ì‹œ ì¶”ê°€ì ì¸ í”ë“¤ë¦¼ (ì˜µì…˜)
            // let slowdownWobble = 0;
            // if (car.element.classList.contains('slowdown')) {
            //    slowdownWobble = Math.sin(timestamp / 50) * 1.5; // ë” ë¹ ë¥´ê³  ê°•í•œ ë–¨ë¦¼
            // }

            car.element.style.transform = `rotate(${angleRad}rad) skewX(${tilt}rad) translateY(${wobble}px)`; // translateY(${wobble + slowdownWobble}px)

            // ë””ë²„ê¹… ì„  ì—…ë°ì´íŠ¸ (ì˜µì…˜)
            // if (car.debugLine) {
            //     car.debugLine.style.left = car.x + 'px';
            //     car.debugLine.style.top = car.y + 'px';
            // ì„  ê¸¸ì´ì™€ ê°ë„ ì¡°ì ˆë¡œ ë°©í–¥ í‘œì‹œ ê°€ëŠ¥
            // car.debugLine.style.height = car.speed * 5 + 'px'; // ì†ë„ë¥¼ ì„  ê¸¸ì´ë¡œ
            // car.debugLine.style.transform = `rotate(${angleRad + Math.PI/2}rad)`; // ì°¨ëŸ‰ ë°©í–¥ìœ¼ë¡œ íšŒì „
            // }

            // DOM ì—…ë°ì´íŠ¸ (ìœ„ì¹˜)
            car.element.style.left = `${car.x - car.element.offsetWidth / 2}px`;
            car.element.style.top = `${car.y - car.element.offsetHeight / 2}px`;

        }); // end forEach car

        // ë© ì¹´ìš´í„° ì—…ë°ì´íŠ¸ (ì„ ë‘ ì°¨ëŸ‰ ê¸°ì¤€) (ë™ì¼)
        if (leadingCar) {
            const displayLap = Math.min(leadingCar.lap + 1, LAPS_TO_WIN);
            lapCounterElement.textContent = `Lap: ${displayLap} / ${LAPS_TO_WIN}`;
        } else if (gameStarted && !gameFinished && cars.length > 0) {
            // ì„ ë‘ê°€ ì—†ì§€ë§Œ ê²Œì„ ì¤‘ì´ë©´ ì²« ë©ìœ¼ë¡œ í‘œì‹œ (ì˜ˆì™¸ ì²˜ë¦¬)
            lapCounterElement.textContent = `Lap: 1 / ${LAPS_TO_WIN}`;
        }

        // ê²Œì„ ì¢…ë£Œ í™•ì¸ (ë™ì¼)
        if (gameStarted && !gameFinished && cars.length > 0 && finishedCars.length === cars.length) {
            endGame();
        } else {
            // ê²Œì„ì´ ê³„ì† ì§„í–‰ ì¤‘ì´ë©´ ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
            animationFrameId = requestAnimationFrame(updateGame);
        }
    } // end updateGame

    // --- ë‚˜ë¨¸ì§€ í•¨ìˆ˜ (handleLapCompletion, updateRaceInfo, endGame) ---
    function handleLapCompletion(car) { // ë™ì¼
        car.lap++;
        // console.log(`Car ${car.number} completed lap ${car.lap}`);
        if (car.lap >= LAPS_TO_WIN && !car.finished) {
            car.finished = true;
            car.speed *= 0.5; // ì™„ì£¼ ì‹œ ì†ë„ ì ˆë°˜ ê°ì†Œ
            car.element.style.zIndex = 10 + finishedCars.length; // ì™„ì£¼ ìˆœì„œëŒ€ë¡œ ìœ„ì— í‘œì‹œ
            car.element.style.boxShadow = '0 0 15px gold'; // ì™„ì£¼ ì‹œ ê¸ˆìƒ‰ í…Œë‘ë¦¬
            car.element.classList.remove('boost', 'slowdown', 'leader-penalty', 'catchup-boost'); // ìƒíƒœ íš¨ê³¼ ì œê±°
            if (!finishedCars.some(finishedCar => finishedCar.number === car.number)) {
                finishedCars.push(car);
                // console.log(`Car ${car.number} finished in position ${finishedCars.length}`);
            }
            updateRaceInfo(); // ìˆœìœ„ ì •ë³´ ì—…ë°ì´íŠ¸
            if (finishedCars.length === 1) {
                raceInfoDiv.textContent = `ğŸ ${car.number}ë²ˆ (${car.name}) ìš°ìŠ¹!`;
            }
        }
    }

    function updateRaceInfo() { // ë™ì¼
        if (finishedCars.length > 0) {
            let info = 'ìˆœìœ„: ';
            finishedCars.forEach((car, index) => {
                let medal = ''; if (index === 0) medal = 'ğŸ¥‡'; else if (index === 1) medal = 'ğŸ¥ˆ'; else if (index === 2) medal = 'ğŸ¥‰';
                info += `${medal}${index + 1}:${car.number} `;
            });
            const remainingCars = cars.filter(c => !c.finished).length; // ì •í™•í•œ ì§„í–‰ ì¤‘ ì°¨ëŸ‰ ìˆ˜
            if (remainingCars > 0 && gameStarted && !gameFinished) info += ` (${remainingCars} ì§„í–‰ì¤‘)`;
            raceInfoDiv.textContent = info;
        } else if (gameStarted) {
            // ë ˆì´ìŠ¤ ì´ˆë°˜, ì„ ë‘ ì •ë³´ í‘œì‹œ (ì„ íƒì )
            const currentLeadingCar = cars.find(c => c.isLeading);
            if (currentLeadingCar) {
                raceInfoDiv.textContent = `ì„ ë‘: ${currentLeadingCar.number}ë²ˆ (${currentLeadingCar.name})`;
            } else {
                raceInfoDiv.textContent = "ë ˆì´ìŠ¤ ì§„í–‰ ì¤‘...";
            }
        }
    }

    function endGame() { // ë™ì¼ (ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼ ë™ì  ìƒì„± ë¶€ë¶„ ì•½ê°„ ìˆ˜ì •)
        if (gameFinished) return;
        gameStarted = false;
        gameFinished = true;
        startButton.disabled = false;
        playerCountInput.disabled = false;
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        updateRaceInfo(); // ìµœì¢… ìˆœìœ„ í‘œì‹œ

        if (finishedCars.length > 0) {
            const firstCar = finishedCars[0];
            resultDiv.innerHTML = `<span style="color: gold; text-shadow: 0 0 5px #ffcc00;">ğŸ† ìš°ìŠ¹: ${firstCar.number}ë²ˆ (${firstCar.name})! ğŸ†</span><br><span style="font-size: 0.8em; color: #555;">(${finishedCars.length}ëŒ€ ì™„ì£¼)</span>`;

            if(firstCar.element) {
                // ìš°ìŠ¹ì ì• ë‹ˆë©”ì´ì…˜ ì ìš© ì „ì— í˜„ì¬ transform ê°’ ê°€ì ¸ì˜¤ê¸°
                const currentTransform = firstCar.element.style.transform;
                // ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼ ë™ì  ìƒì„± (ê¸°ì¡´ transform ìœ ì§€í•˜ë©° scale/shadow ë³€ê²½)
                let styleSheet = document.getElementById('pulse-animation-style');
                if (!styleSheet) {
                    styleSheet = document.createElement('style'); styleSheet.id = 'pulse-animation-style';
                    document.head.appendChild(styleSheet);
                }
                // @keyframes ì •ì˜ ì‹œ í˜„ì¬ transform ê°’ì„ ì‹œì‘/ë ê°’ìœ¼ë¡œ ì‚¬ìš©
                // ì£¼ì˜: íšŒì „ê°’(rotate) ë“± ë‹¤ë¥¸ transform ìš”ì†Œë„ ìœ ì§€í•´ì•¼ ìì—°ìŠ¤ëŸ¬ì›€
                // ê°„ë‹¨í•˜ê²Œ scaleê³¼ shadowë§Œ ë³€ê²½í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •
                styleSheet.textContent = `
                    @keyframes pulse {
                        0%, 100% {
                            transform: ${currentTransform} scale(1);
                            box-shadow: 0 0 15px gold;
                        }
                        50% {
                            transform: ${currentTransform} scale(1.1);
                            box-shadow: 0 0 25px gold, 0 0 35px rgba(255, 215, 0, 0.6);
                        }
                    }`;
                firstCar.element.style.animation = 'pulse 1s infinite ease-in-out';
            }
        } else {
            resultDiv.textContent = "ê²½ê¸°ê°€ ì •ìƒì ìœ¼ë¡œ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.";
        }

        // ì¬ì‹œì‘ ì•ˆë‚´ ë©”ì‹œì§€ (ë™ì¼)
        setTimeout(() => {
            const restartMessage = document.createElement('div');
            restartMessage.innerHTML = `<br><span style="font-size: 0.8em;">ìƒˆ ê²Œì„ì„ ì‹œì‘í•˜ë ¤ë©´ 'ê²Œì„ ì‹œì‘' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</span>`;
            if(document.getElementById('result')) document.getElementById('result').appendChild(restartMessage);
        }, 1500);
    }
</script>
</body>
</html>
