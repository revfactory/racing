
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>레이싱 게임</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      height: 100%;
      background-color: #f0f0f0;
    }
    
    #game-container {
      width: 800px;
      height: 600px;
      margin: 20px auto;
      position: relative;
      background-color: #5da45d;
      overflow: hidden;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }
    
    .car {
      position: absolute;
      width: 40px;
      height: 25px;
      border-radius: 8px 5px 5px 5px;
      text-align: center;
      line-height: 25px;
      font-weight: bold;
      color: white;
      will-change: transform, left, top;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      z-index: 10;
    }
    
    .car::before {
      content: '';
      position: absolute;
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
      top: 5px;
      left: 5px;
      box-shadow: 0 0 2px white;
    }
    
    .car::after {
      content: '';
      position: absolute;
      width: 4px;
      height: 2px;
      background: red;
      border-radius: 1px;
      bottom: 3px;
      right: 5px;
      box-shadow: -8px 0 0 red;
    }
    
    .track {
      position: absolute;
      width: 650px;
      height: 350px;
      border: 15px solid #333;
      border-radius: 170px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-sizing: border-box;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    
    /* 트랙 표면 */
    .track::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #444;
      border-radius: 170px;
      z-index: 1;
    }
    
    .finish-line {
      position: absolute;
      width: 60px;
      height: 20px;
      background: repeating-linear-gradient(
        90deg,
        #000,
        #000 5px,
        #fff 5px,
        #fff 10px
      );
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 2px;
      z-index: 5;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    
    /* 트랙 안쪽 영역 */
    .track-inner {
      position: absolute;
      width: 70%;
      height: 60%;
      background: #5da45d;
      border-radius: 140px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
    }
    
    /* 트랙 차선 */
    .lane-markings {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 3;
      border-radius: 170px;
      overflow: hidden;
    }
    
    .lane-marking {
      position: absolute;
      background: rgba(255, 255, 255, 0.5);
      width: 20px;
      height: 3px;
    }
    
    /* 트랙 코너 표시 */
    .corner-marker {
      position: absolute;
      width: 12px;
      height: 40px;
      background: #ff0000;
      z-index: 3;
      transform-origin: center;
    }
    
    .controls {
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background-color: #333;
      color: white;
      border-radius: 5px;
    }
    
    button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin: 0 10px;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    input {
      width: 50px;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #ccc;
      margin: 0 10px;
      text-align: center;
    }
    
    .result {
      text-align: center;
      font-size: 24px;
      margin-top: 20px;
      font-weight: bold;
      color: #333;
    }
    
    .race-info {
      text-align: center;
      padding: 10px;
      font-size: 18px;
      background-color: rgba(255, 255, 255, 0.7);
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 5px;
      width: 80%;
      z-index: 20;
    }
    
    @keyframes flagWave {
      0% { transform: rotate(-5deg); }
      100% { transform: rotate(5deg); }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div class="track">
      <div class="track-inner"></div>
      <div class="lane-markings" id="lane-markings"></div>
      <div class="finish-line"></div>
    </div>
    <div class="race-info" id="race-info"></div>
  </div>
  
  <div class="controls">
    <label for="player-count">참가자 수:</label>
    <input type="number" id="player-count" min="2" max="8" value="4">
    <button id="start-button">게임 시작</button>
  </div>
  
  <div class="result" id="result"></div>

  <script>
    // 게임 요소
    const gameContainer = document.getElementById('game-container');
    const track = document.querySelector('.track');
    const laneMarkings = document.getElementById('lane-markings');
    const startButton = document.getElementById('start-button');
    const playerCountInput = document.getElementById('player-count');
    const resultDiv = document.getElementById('result');
    const raceInfoDiv = document.getElementById('race-info');
    
    // 게임 상태
    let cars = [];
    let gameStarted = false;
    let gameFinished = false;
    let finishedCars = [];
    let lastTimestamp = 0;
    let gameTime = 0;
    
    // 차량 색상
    const carColors = [
      "#FF0000", // 빨강
      "#0000FF", // 파랑
      "#00FF00", // 초록
      "#FFFF00", // 노랑
      "#FF00FF", // 마젠타
      "#00FFFF", // 시안
      "#FFA500", // 주황
      "#800080"  // 보라
    ];
    
    // 색상이 밝은지 어두운지 판단하는 함수
    function isLightColor(color) {
      // 색상 코드에서 RGB 추출 및 밝기 계산
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      // 밝기 계산 (YIQ 공식)
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      
      // 밝기가 128보다 크면 밝은색, 그렇지 않으면 어두운색
      return brightness > 128;
    }
    
    // 게임 초기화 및 시작
    startButton.addEventListener('click', startGame);
    
    // 애니메이션 프레임 요청
    requestAnimationFrame(updateGame);
    
    // 레인 마킹 생성
    function createLaneMarkings() {
      // 기존 마킹 제거
      while (laneMarkings.firstChild) {
        laneMarkings.removeChild(laneMarkings.firstChild);
      }
      
      const trackRect = track.getBoundingClientRect();
      const centerX = trackRect.width / 2;
      const centerY = trackRect.height / 2;
      
      // 레인 마킹 추가 (점선)
      const markingCount = 40;
      for (let i = 0; i < markingCount; i++) {
        const angle = (Math.PI * 2 * i) / markingCount;
        const x = centerX + Math.cos(angle) * (trackRect.width * 0.4);
        const y = centerY + Math.sin(angle) * (trackRect.height * 0.4);
        
        const marking = document.createElement('div');
        marking.className = 'lane-marking';
        marking.style.left = `${x}px`;
        marking.style.top = `${y}px`;
        marking.style.transform = `translate(-50%, -50%) rotate(${angle + Math.PI/2}rad)`;
        
        laneMarkings.appendChild(marking);
      }
    }
    
    // 경로 생성
    function createPaths() {
      const trackRect = track.getBoundingClientRect();
      const gameRect = gameContainer.getBoundingClientRect();
      
      // 트랙 위치
      const trackLeft = trackRect.left - gameRect.left;
      const trackTop = trackRect.top - gameRect.top;
      const trackWidth = trackRect.width;
      const trackHeight = trackRect.height;
      
      // 중앙 좌표
      const centerX = trackLeft + trackWidth / 2;
      const centerY = trackTop + trackHeight / 2;
      
      // 레인 수 및 간격
      const laneCount = 3;
      const paths = [];
      
      // 각 레인 경로 생성
      for (let lane = 0; lane < laneCount; lane++) {
        const lanePoints = [];
        const segments = 60; // 세그먼트 수
        
        // 레인별 반경 설정 - 안쪽부터 바깥쪽으로
        const radiusOffset = 25 + lane * 30; // 각 레인의 반경 차이
        const radiusX = trackWidth / 2 - radiusOffset;
        const radiusY = trackHeight / 2 - radiusOffset;
        
        // 시작점은 하단 중앙
        const startAngle = Math.PI / 2;
        
        // 각 포인트 생성
        for (let i = 0; i <= segments; i++) {
          const angle = startAngle + (Math.PI * 2 * i) / segments;
          const x = centerX + Math.cos(angle) * radiusX;
          const y = centerY + Math.sin(angle) * radiusY;
          lanePoints.push({ x, y, lane });
        }
        
        paths.push(lanePoints);
      }
      
      return paths;
    }
    
    // 차량 생성
    function createCars(count) {
      // 차량 초기화
      cars = [];
      
      // 경로 생성
      const paths = createPaths();
      createLaneMarkings();
      
      console.log(`${paths.length}개 레인으로 ${count}대 차량 생성 중...`);
      
      for (let i = 0; i < count; i++) {
        // 차량별 레인 할당
        const lane = i % paths.length;
        const lanePoints = paths[lane];
        
        // 시작점
        const startPoint = lanePoints[0];
        
        // 시작 위치 계산
        const offset = 10 * (i - Math.floor(count / 2)); // 좌우 간격
        
        // 차량 요소 생성
        const carElement = document.createElement('div');
        carElement.className = 'car';
        carElement.textContent = (i + 1);
        
        // 차량 색상
        const carColor = carColors[i % carColors.length];
        carElement.style.backgroundColor = carColor;
        
        // 밝은 색상일 경우 텍스트 색상을 검정으로 변경
        if (isLightColor(carColor)) {
          carElement.style.color = 'black';
        }
        
        gameContainer.appendChild(carElement);
        
        // 차량 타입 결정 (0: 밸런스, 1: 가속, 2: 속도, 3: 코너링)
        const carType = Math.floor(Math.random() * 4);
        let maxSpeed, acceleration, corneringBonus;
        
        switch (carType) {
          case 0: // 밸런스형
            maxSpeed = 0.5 + Math.random() * 0.2;
            acceleration = 0.005 + Math.random() * 0.003;
            corneringBonus = 1.0;
            break;
          case 1: // 가속 특화
            maxSpeed = 0.45 + Math.random() * 0.15;
            acceleration = 0.008 + Math.random() * 0.004;
            corneringBonus = 0.8;
            break;
          case 2: // 속도 특화
            maxSpeed = 0.6 + Math.random() * 0.25;
            acceleration = 0.003 + Math.random() * 0.002;
            corneringBonus = 0.7;
            break;
          case 3: // 코너링 특화
            maxSpeed = 0.48 + Math.random() * 0.17;
            acceleration = 0.004 + Math.random() * 0.003;
            corneringBonus = 1.5;
            break;
        }
        
        // 차량 데이터
        const car = {
          element: carElement,
          number: i + 1,
          lane: lane,
          targetLane: lane,
          isChangingLane: false,
          laneChangeProgress: 0,
          lastLaneChangeTime: 0,
          
          x: startPoint.x + offset,
          y: startPoint.y,
          
          speed: 0,
          maxSpeed: maxSpeed,
          baseMaxSpeed: maxSpeed,
          acceleration: acceleration,
          corneringBonus: corneringBonus,
          
          type: carType,
          
          finished: false,
          lap: 0,
          pathIndex: 0,
          position: i,
          pathProgress: 0,
          
          color: carColor,
          
          position: { x: 0, y: 0 },
          targetPosition: { x: 0, y: 0 },
          
          // AI 데이터
          preferredLine: Math.random(),
          aggressiveness: 0.3 + Math.random() * 0.7,
          mistakes: 0,
          overtakes: 0,
          totalDistance: 0
        };
        
        // 시작 위치 설정
        car.position.x = car.x;
        car.position.y = car.y;
        car.targetPosition.x = car.x;
        car.targetPosition.y = car.y;
        
        car.element.style.left = `${car.x}px`;
        car.element.style.top = `${car.y}px`;
        
        cars.push(car);
      }
      
      console.log(`${cars.length}대 차량 생성 완료`);
    }
    
    // 차량 제거
    function clearCars() {
      cars.forEach(car => {
        if (car.element && car.element.parentNode) {
          car.element.parentNode.removeChild(car.element);
        }
      });
      cars = [];
      finishedCars = [];
    }
    
    // 순위 계산
    function checkForOvertaking(cars) {
      const racingOrder = [...cars].sort((a, b) => {
        if (a.lap !== b.lap) return b.lap - a.lap;
        if (a.pathIndex !== b.pathIndex) return b.pathIndex - a.pathIndex;
        return b.pathProgress - a.pathProgress;
      });
      
      racingOrder.forEach((car, index) => {
        if (car.position !== index && !car.finished) {
          if (car.position > index && car.position !== 0) {
            car.overtakes++;
          }
        }
        car.position = index;
      });
      
      return racingOrder;
    }
    
    // 차선 변경 결정
    function decideLaneChange(car, paths, racingOrder, timestamp) {
      if (car.finished || car.isChangingLane) return;
      
      const laneChangeCooldown = 3000; // 3초
      if (timestamp - car.lastLaneChangeTime < laneChangeCooldown) return;
      
      const carPosition = car.position;
      const carsAhead = racingOrder.filter(c => 
        c.position < carPosition && 
        c.position >= carPosition - 2 && 
        !c.finished && 
        c.lane === car.lane &&
        Math.abs(c.pathIndex - car.pathIndex) < 20
      );
      
      if (carsAhead.length > 0 && Math.random() < car.aggressiveness * 0.3) {
        const possibleLanes = [];
        
        if (car.lane > 0) possibleLanes.push(car.lane - 1);
        if (car.lane < paths.length - 1) possibleLanes.push(car.lane + 1);
        
        if (possibleLanes.length > 0) {
          const newLane = possibleLanes[Math.floor(Math.random() * possibleLanes.length)];
          car.targetLane = newLane;
          car.isChangingLane = true;
          car.laneChangeProgress = 0;
          car.lastLaneChangeTime = timestamp;
        }
      }
    }
    
    // 게임 렌더링 업데이트
    function updateGame(timestamp) {
      if (!gameStarted) {
        requestAnimationFrame(updateGame);
        return;
      }
      
      // 시간 계산
      if (lastTimestamp === 0) lastTimestamp = timestamp;
      const deltaTime = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;
      gameTime += deltaTime;
      
      // 클램핑
      const clampedDelta = Math.min(deltaTime, 0.1);
      
      // 활성 차량 수
      let activeCars = 0;
      
      // 패스 생성
      const paths = createPaths();
      
      // 차량 업데이트
      cars.forEach(car => {
        if (car.finished) return;
        activeCars++;
        
        // 코너링 감지
        const segments = paths[0].length;
        const quarterTrack = segments / 4;
        const isInCorner = (
          (car.pathIndex > quarterTrack * 0.7 && car.pathIndex < quarterTrack * 1.3) ||
          (car.pathIndex > quarterTrack * 1.7 && car.pathIndex < quarterTrack * 2.3) ||
          (car.pathIndex > quarterTrack * 2.7 && car.pathIndex < quarterTrack * 3.3) ||
          (car.pathIndex > quarterTrack * 3.7 || car.pathIndex < quarterTrack * 0.3)
        );
        
        // 코너에서 감속
        if (isInCorner) {
          car.maxSpeed = car.baseMaxSpeed * (0.7 + (car.corneringBonus * 0.2));
          
          // 코너링 실수 확률
          const mistakeChance = 0.001 * (1 - car.corneringBonus);
          if (Math.random() < mistakeChance && car.speed > car.maxSpeed * 0.8) {
            car.speed *= 0.7;
            car.mistakes++;
          }
        } else {
          car.maxSpeed = car.baseMaxSpeed;
        }
        
        // 가속
        car.speed = Math.min(
          car.speed + car.acceleration * clampedDelta * 60,
          car.maxSpeed
        );
        
        // 현재 레인과 타겟 레인
        const currentLane = Math.min(car.lane, paths.length - 1);
        const targetLane = car.isChangingLane ? 
          Math.min(car.targetLane, paths.length - 1) : 
          currentLane;
        
        const lanePoints = paths[currentLane];
        const targetLanePoints = paths[targetLane];
        
        // 인덱스 계산
        const pointIndex = Math.floor(car.pathIndex) % lanePoints.length;
        const nextIndex = (pointIndex + 1) % lanePoints.length;
        
        const currentPoint = lanePoints[pointIndex];
        const nextPoint = lanePoints[nextIndex];
        
        // 세그먼트 길이 계산
        const dx = nextPoint.x - currentPoint.x;
        const dy = nextPoint.y - currentPoint.y;
        const segmentLength = Math.sqrt(dx * dx + dy * dy);
        
        // 진행률 업데이트
        car.pathProgress += car.speed * clampedDelta * 60;
        car.totalDistance += car.speed * clampedDelta;
        
        // 세그먼트 전환
        if (car.pathProgress >= segmentLength) {
          car.pathProgress -= segmentLength;
          car.pathIndex = (car.pathIndex + 1) % lanePoints.length;
          
          // 랩 완료 체크
          if (car.pathIndex === 0) {
            car.lap++;
            
            raceInfoDiv.textContent = `${car.number}번 차량 ${car.lap}바퀴 완료!`;
            
            // 2바퀴 완료시 종료
            if (car.lap >= 2) {
              car.finished = true;
              car.element.style.boxShadow = '0 0 15px gold';
              
              finishedCars.push(car);
              updateRaceInfo();
              
              if (finishedCars.length === cars.length) {
                endGame();
              } else if (finishedCars.length === 1) {
                raceInfoDiv.textContent = `${car.number}번 차량이 우승했습니다!`;
              }
            }
          }
        }
        
        // 차선 변경 처리
        if (car.isChangingLane) {
          car.laneChangeProgress += clampedDelta * 2;
          
          if (car.laneChangeProgress >= 1) {
            car.lane = car.targetLane;
            car.isChangingLane = false;
          }
        }
        
        // 위치 계산 
        const t = car.pathProgress / segmentLength;
        
        // 차선 변경 중이면 보간
        if (car.isChangingLane) {
          const targetPoint = targetLanePoints[pointIndex];
          const targetNextPoint = targetLanePoints[nextIndex];
          
          const currentX = currentPoint.x + dx * t;
          const currentY = currentPoint.y + dy * t;
          
          const targetDx = targetNextPoint.x - targetPoint.x;
          const targetDy = targetNextPoint.y - targetPoint.y;
          const targetX = targetPoint.x + targetDx * t;
          const targetY = targetPoint.y + targetDy * t;
          
          const lerpAmount = Math.sin(car.laneChangeProgress * Math.PI / 2);
          car.x = currentX + (targetX - currentX) * lerpAmount;
          car.y = currentY + (targetY - currentY) * lerpAmount;
        } else {
          car.x = currentPoint.x + dx * t;
          car.y = currentPoint.y + dy * t;
        }
        
        // 각도 계산
        const angle = Math.atan2(dy, dx);
        
        // 진동 효과
        const wobble = Math.sin(timestamp / 100 + car.number) * (car.speed / 5);
        
        // 코너링 틸트
        let tilt = 0;
        if (isInCorner) {
          if (car.pathIndex < quarterTrack * 1.5) {
            tilt = -0.15;
          } else if (car.pathIndex < quarterTrack * 3) {
            tilt = 0.15;
          } else {
            tilt = -0.15;
          }
        }
        
        // 변환 적용
        car.element.style.transform = `rotate(${angle + Math.PI/2}rad) skewX(${tilt}rad) translateY(${wobble}px)`;
        car.element.style.left = `${car.x}px`;
        car.element.style.top = `${car.y}px`;
      });
      
      // 순위 계산
      const racingOrder = checkForOvertaking(cars);
      
      // 차선 변경 결정 (0.5초마다)
      if (Math.floor(gameTime * 2) !== Math.floor((gameTime - deltaTime) * 2)) {
        cars.forEach(car => {
          decideLaneChange(car, paths, racingOrder, timestamp);
        });
      }
      
      // 다음 프레임
      requestAnimationFrame(updateGame);
    }
    
    // 순위 표시 업데이트
    function updateRaceInfo() {
      if (finishedCars.length > 0) {
        let info = '순위: ';
        finishedCars.forEach((car, index) => {
          info += `${index + 1}등: ${car.number}번 차량 `;
        });
        raceInfoDiv.textContent = info;
      }
    }
    
    // 게임 종료
    function endGame() {
      gameStarted = false;
      gameFinished = true;
      
      updateRaceInfo();
      
      const lastCar = finishedCars[finishedCars.length - 1];
      const firstCar = finishedCars[0];
      
      resultDiv.innerHTML = `
        <span style="color: gold; text-shadow: 0 0 5px #ffcc00;">우승: ${firstCar.number}번 차량!</span><br>
        <span style="font-size: 0.8em; color: #666;">마지막 도착: ${lastCar.number}번 차량</span>
      `;
      
      finishedCars.forEach((car, index) => {
        if (index === 0) {
          car.element.style.boxShadow = '0 0 20px gold';
          car.element.style.animation = 'pulse 1s infinite';
          
          if (!document.querySelector('#winner-pulse')) {
            const style = document.createElement('style');
            style.id = 'winner-pulse';
            style.textContent = `
              @keyframes pulse {
                0% { box-shadow: 0 0 20px gold; }
                50% { box-shadow: 0 0 30px gold, 0 0 40px rgba(255, 215, 0, 0.5); }
                100% { box-shadow: 0 0 20px gold; }
              }
            `;
            document.head.appendChild(style);
          }
        }
      });
      
      setTimeout(() => {
        resultDiv.innerHTML += '<br><span style="font-size: 0.8em;">다시 시작하려면 게임 시작 버튼을 누르세요.</span>';
      }, 2000);
    }
    
    // 게임 시작
    function startGame() {
      console.log("게임 시작");
      
      clearCars();
      
      gameStarted = true;
      gameFinished = false;
      finishedCars = [];
      
      resultDiv.textContent = '';
      raceInfoDiv.textContent = '레이스 시작!';
      
      const playerCount = parseInt(playerCountInput.value) || 4;
      createCars(Math.min(Math.max(playerCount, 2), 8));
      
      lastTimestamp = 0;
      gameTime = 0;
    }
  </script>
</body>
</html>
